<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Spam Musubi</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, Helvetica, sans-serif;
        }

        h1 {
            font-size: 128px;
            position: fixed;
            top: 10px;
            left: 20px;
            margin: 0;
            line-height: 1;
            z-index: 1;
            user-select: none;
            opacity: 0.6;
        }

        .link-actions {
            position: fixed;
            margin: 1rem;
            z-index: 1;
            bottom: 10px;
            right: 10px;
        }
    </style>
</head>

<body>
    <h1 id="counter">0</h1>

    <div class="link-actions">
        <a href="https://github.com/yuan-miranda/stiwebscraper" target="_blank" aria-label="GitHub Repository">
            <img src="media/icon/github-mark.svg" alt="GitHub" width="32" height="32" title="GitHub Repository">
        </a>
    </div>

    <script>
        const THREE_VERSION = "0.179.1";
        const importMap = {
            "imports": {
                "three": `https://cdn.jsdelivr.net/npm/three@${THREE_VERSION}/build/three.module.js`,
                "three/addons/": `https://cdn.jsdelivr.net/npm/three@${THREE_VERSION}/examples/jsm/`
            }
        };

        document.head.appendChild(Object.assign(document.createElement('script'), {
            type: 'importmap',
            textContent: JSON.stringify(importMap)
        }));
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const config = {
            miniMusubiScale: 0.2,
            gravity: 9.81,
            removeFloorY: -3
        }

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xF0F0F0);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3;
        camera.position.y = 2;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enablePan = false;

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x888888, 0.6);
        hemiLight.position.set(0, 1, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(3, 5, 2);
        scene.add(dirLight);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let musubiModel = null;
        let miniMusubis = [];

        // https://skfb.ly/oVqKQ
        const loader = new GLTFLoader();
        loader.load('spam_musubi.glb', (gltf) => {
            musubiModel = gltf.scene;
            musubiModel.position.y = -0.5;
            musubiModel.rotation.y = Math.PI / 2;
            scene.add(musubiModel);
        });

        const clock = new THREE.Clock();
        let clickCount = 0;
        const counter = document.getElementById('counter');

        window.addEventListener('click', ({ clientX, clientY }) => {
            if (!musubiModel) return;

            mouse.set(
                (clientX / window.innerWidth) * 2 - 1,
                -(clientY / window.innerHeight) * 2 + 1
            );

            raycaster.setFromCamera(mouse, camera);
            const [intersect] = raycaster.intersectObject(musubiModel, true);
            if (!intersect) return;

            const miniMusubi = musubiModel.clone();
            miniMusubi.scale.setScalar(config.miniMusubiScale);
            miniMusubi.position.copy(intersect.point);
            miniMusubis.push({
                mesh: miniMusubi,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    1 + Math.random() * 0.5,
                    (Math.random() - 0.5) * 0.5
                ),
                rotationSpeed: new THREE.Vector3(
                    (Math.random() - 0.5) * 6,
                    (Math.random() - 0.5) * 6,
                    (Math.random() - 0.5) * 6
                )
            });
            scene.add(miniMusubi);

            clickCount++;
            counter.innerText = clickCount;
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const delta = clock.getDelta();

            for (let i = miniMusubis.length - 1; i >= 0; i--) {
                const { mesh, velocity, rotationSpeed } = miniMusubis[i];
                velocity.y -= config.gravity * delta;
                mesh.position.addScaledVector(velocity, delta);
                mesh.rotation.x += rotationSpeed.x * delta;
                mesh.rotation.y += rotationSpeed.y * delta;
                mesh.rotation.z += rotationSpeed.z * delta;

                if (mesh.position.y < config.removeFloorY) {
                    scene.remove(mesh);
                    miniMusubis.splice(i, 1);
                }
            }
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>